<!DOCTYPE HTML>
<html lang="en" class="sidebar-visible no-js light">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>DOS Guide</title>
        
        <meta name="robots" content="noindex" />
        
        


        <!-- Custom HTML head -->
        


        <meta content="text/html; charset=utf-8" http-equiv="Content-Type">
        <meta name="description" content="GMT Dynamic Optics Simulation User Guide">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff" />

        
        <link rel="icon" href="favicon.svg">
        
        
        <link rel="shortcut icon" href="favicon.png">
        
        <link rel="stylesheet" href="css/variables.css">
        <link rel="stylesheet" href="css/general.css">
        <link rel="stylesheet" href="css/chrome.css">
        
        <link rel="stylesheet" href="css/print.css" media="print">
        

        <!-- Fonts -->
        <link rel="stylesheet" href="FontAwesome/css/font-awesome.css">
        
        <link rel="stylesheet" href="fonts/fonts.css">
        

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="highlight.css">
        <link rel="stylesheet" href="tomorrow-night.css">
        <link rel="stylesheet" href="ayu-highlight.css">

        <!-- Custom theme stylesheets -->
        

        
    </head>
    <body>
        <!-- Provide site root to javascript -->
        <script type="text/javascript">
            var path_to_root = "";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "navy" : "light";
        </script>

        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script type="text/javascript">
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script type="text/javascript">
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            var html = document.querySelector('html');
            html.classList.remove('no-js')
            html.classList.remove('light')
            html.classList.add(theme);
            html.classList.add('js');
        </script>

        <!-- Hide / unhide sidebar before it is displayed -->
        <script type="text/javascript">
            var html = document.querySelector('html');
            var sidebar = 'hidden';
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            }
            html.classList.remove('sidebar-visible');
            html.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <div class="sidebar-scrollbox">
                <ol class="chapter"><li class="chapter-item expanded affix "><a href="introduction.html">Introduction</a></li><li class="chapter-item expanded "><a href="getting-started.html"><strong aria-hidden="true">1.</strong> Getting Started</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="getting-started/installation.html"><strong aria-hidden="true">1.1.</strong> Installation</a></li><li class="chapter-item expanded "><a href="getting-started/dos-interface.html"><strong aria-hidden="true">1.2.</strong> DOS Interface</a></li></ol></li><li class="chapter-item expanded "><a href="optical-model.html"><strong aria-hidden="true">2.</strong> Optical Model</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="optical-model/installation.html"><strong aria-hidden="true">2.1.</strong> Installation</a></li><li class="chapter-item expanded "><a href="optical-model/dos-interface.html"><strong aria-hidden="true">2.2.</strong> DOS Interface</a></li></ol></li><li class="chapter-item expanded "><a href="fem.html"><strong aria-hidden="true">3.</strong> Finite Element Model</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="fem/installation.html"><strong aria-hidden="true">3.1.</strong> Installation</a></li><li class="chapter-item expanded "><a href="fem/dos-interface.html"><strong aria-hidden="true">3.2.</strong> DOS Interface</a></li></ol></li><li class="chapter-item expanded "><a href="wind-loading.html"><strong aria-hidden="true">4.</strong> Wind Loading</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="wind-loading/installation.html"><strong aria-hidden="true">4.1.</strong> Installation</a></li><li class="chapter-item expanded "><a href="wind-loading/dos-interface.html"><strong aria-hidden="true">4.2.</strong> DOS Interface</a></li></ol></li><li class="chapter-item expanded "><a href="controllers.html"><strong aria-hidden="true">5.</strong> Controllers</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="controllers/simulink.html"><strong aria-hidden="true">5.1.</strong> Simulink</a></li></ol></li><li class="chapter-item expanded "><a href="appendix.html"><strong aria-hidden="true">6.</strong> Appendix</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="dos-io-variants.html"><strong aria-hidden="true">6.1.</strong> IO variants</a></li></ol></li></ol>
            </div>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle"></div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                
                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky bordered">
                    <div class="left-buttons">
                        <button id="sidebar-toggle" class="icon-button" type="button" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </button>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light (default)</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        
                        <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                        
                    </div>

                    <h1 class="menu-title">DOS Guide</h1>

                    <div class="right-buttons">
                        
                        <a href="print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>
                        
                        
                        <a href="https://github.com/rconan/dos-guide" title="Git repository" aria-label="Git repository">
                            <i id="git-repository-button" class="fa fa-github"></i>
                        </a>
                        
                    </div>
                </div>

                
                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" name="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>
                

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script type="text/javascript">
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h1 id="introduction"><a class="header" href="#introduction">Introduction</a></h1>
<p>The <em>Dynamic Optics Simulation</em>, or <em>DOS</em> for short, is the simulation software developed by the Integrated Modeling team of the GMTO project to write the end-to-end models of the Observatory.
As its core, the <em>DOS</em> provide a software framework to build the necessary interfaces with the many components of the end-to-end model like the <a href="ch01-00-optical-model.html">optical model</a> or the <a href="ch02-00-fem.html">finite element model</a>. 
The <em>DOS</em> framework also provides all the possible inputs and outputs to the different model components.</p>
<p>The <em>DOS</em> framework is written in <a href="https://www.rust-lang.org">Rust</a>, the Rust language is a high level zero-cost abstraction language that is well suited for this kind of high performance computing application as, once compiled, and despite beeing a high level language, the runtime execution speed is comparable to what would have given a C or C++ equivalent program.</p>
<p>A <em>DOS</em> simulation is built from a collection of models, each model is implemented within a different Rust crate.
In each crate, there is an implementation of the <em>DOS</em> interface that allows the different models to communicate by passing data to each other.</p>
<p>The models currently available are listed in the table below:</p>
<table><thead><tr><th>Model</th><th>Crate</th><th>Github</th><th>Doc</th><th>Examples</th></tr></thead><tbody>
<tr><td>Optical Model</td><td>crseo</td><td><a href="https://github.com/rconan/crseo"><img style="display: inline! important" src="https://img.shields.io/badge/src-main-green.svg"></img></a></td><td><a href="https://rconan.github.io/crseo"><img style="display: inline! important" src="https://img.shields.io/badge/doc-current-green.svg"></img></a></td><td><a href="https://github.com/rconan/dos-guide/tree/main/examples/optical-model/gmt_optical_model">@</a>, <a href="https://github.com/rconan/dos-guide/tree/main/examples/optical-model/gmt_optical_sensor_model">@</a></td></tr>
<tr><td>Finite Element Model</td><td>fem</td><td><a href="https://github.com/rconan/fem/tree/dos"><img style="display: inline! important" src="https://img.shields.io/badge/src-dos-green.svg"></img></a></td><td><a href="https://rconan.github.io/fem"><img style="display: inline! important" src="https://img.shields.io/badge/doc-current-green.svg"></img></a></td><td><a href="https://github.com/rconan/dos-guide/tree/main/examples/fem">@</a></td></tr>
<tr><td>Wind Loading</td><td>windloading</td><td><a href="https://github.com/rconan/windloading"><img style="display: inline! important" src="https://img.shields.io/badge/src-main-green.svg"></img></a></td><td><a href="https://rconan.github.io/windloading"><img style="display: inline! important" src="https://img.shields.io/badge/doc-current-green.svg"></img></a></td><td><a href="https://github.com/rconan/dos-guide/tree/main/examples/wind-loading">@</a></td></tr>
<tr><td>Mount Control System</td><td>mount-ctrl</td><td><a href="https://github.com/rconan/mount-ctrl"><img style="display: inline! important" src="https://img.shields.io/badge/src-main-green.svg"></img></a></td><td><a href="https://rconan.github.io/mount-ctrl"><img style="display: inline! important" src="https://img.shields.io/badge/doc-current-red.svg"></img></a></td><td><a href="https://github.com/rconan/dos-guide/tree/main/examples/controllers/simulink">@</a></td></tr>
<tr><td>M1 Control System</td><td>m1-ctrl</td><td><a href="https://github.com/rconan/m1-ctrl"><img style="display: inline! important" src="https://img.shields.io/badge/src-main-green.svg"></img></a></td><td><a href="https://rconan.github.io/m1-ctrl"><img style="display: inline! important" src="https://img.shields.io/badge/doc-current-red.svg"></img></a></td><td><a href="https://github.com/rconan/dos-guide/tree/main/examples/controllers/simulink">@</a></td></tr>
</tbody></table>
<p>In addition to the crates for the models, there are other crates that provide specific interfaces:</p>
<table><thead><tr><th>Interface</th><th>Crate</th><th>Github</th><th>Doc</th></tr></thead><tbody>
<tr><td>Dos</td><td>dosio</td><td><a href="https://github.com/rconan/dosio"><img style="display: inline! important" src="https://img.shields.io/badge/src-main-green.svg"></img></a></td><td><a href="https://rconan.github.io/dosio"><img style="display: inline! important" src="https://img.shields.io/badge/doc-current-green.svg"></img></a></td></tr>
<tr><td>Simulink</td><td>simulink-rs</td><td><a href="https://github.com/rconan/simulink-rs"><img style="display: inline! important" src="https://img.shields.io/badge/src-main-green.svg"></img></a></td><td><a href="https://rconan.github.io/simulink-rs"><img style="display: inline! important" src="https://img.shields.io/badge/doc-current-green.svg"></img></a></td></tr>
</tbody></table>
<h1 id="getting-started"><a class="header" href="#getting-started">Getting Started</a></h1>
<p>To get started with <em>DOS</em>, you need, first, to install Rust and, second, to get familiar with the <em>DOS</em> interface.</p>
<h2 id="installation"><a class="header" href="#installation">Installation</a></h2>
<p>To install Rust, follow the instructions on the <a href="https://www.rust-lang.org/tools/install">Rust installation page</a>.</p>
<h2 id="dos-interface"><a class="header" href="#dos-interface">DOS Interface</a></h2>
<p>The DOS Interface is defined in the Rust crate <a href="https://github.com/rconan/dosio">dosio</a>. 
<a href="https://rconan.github.io/dosio"><code>dosio</code></a> consists in the enum <code>IO</code> with as many variants as there are inputs and outputs to <em>DOS</em> and in the trait <code>Dos</code>. 
Every component that needs to be included in a DOS end-to-end model, must implement the <code>inputs</code> and <code>outputs</code> methods of the <code>Dos</code> trait as well as implementing the <a href="https://doc.rust-lang.org/std/iter/index.html#implementing-iterator"><code>Iterator</code></a> trait.
The inputs data to the component is passed as an argument to the <code>inputs</code> method and the component outputs is returned by the <code>outputs</code> method.
Both inputs and outputs data are contained into variants of the <code>IO</code> enum.
The state of the component is updated with the <code>step</code> method of the <code>Dos</code> trait which in turns calls the <code>next</code> method of the <code>Iterator</code> trait implemented by the component.</p>
<p>In the following example, a simple integrator controller is integrated with DOS using the interface defined in the crate <code>dosio</code>. </p>
<h3 id="example"><a class="header" href="#example">Example</a></h3>
<p>A new project is created with Cargo:</p>
<pre><code class="language-console">$ cargo init
</code></pre>
<p>The Cargo command creates a <em>Cargo.toml</em> file
and a <em>main.rs</em> file in the <em>src</em> directory.
The <em>Cargo.toml</em> contains the package meta-data and an optional list of the project dependencies, which is empty for now:</p>
<pre><code class="language-toml">[package]
name = &quot;ch01-02-dos-api&quot;
version = &quot;0.1.0&quot;
authors = [&quot;Rod Conan &lt;rconan@gmto.org&gt;&quot;]
edition = &quot;2018&quot;

[dependencies]
</code></pre>
<p>In the <em>main.rs</em> file, we add the simple integrator model represented by the <code>Integrate</code> structure and implement the <code>Iterator</code>  trait for the <code>Integrate</code> structure:</p>
<pre><code class="language-rust ignore">#[derive(Default)]
pub struct Integrate {
    /// integrator gain
    gain: f64,
    /// output vector
    y: Vec&lt;f64&gt;,
    /// input vector
    u: Vec&lt;f64&gt;,
}
impl Integrate {
    pub fn new(gain: f64, n_data: usize) -&gt; Self {
        Self {
            gain,
            y: vec![0f64; n_data],
            ..Default::default()
        }
    }
    pub fn output(&amp;self) -&gt; Option&lt;Vec&lt;f64&gt;&gt; {
        Some(self.y.clone())
    }
}
impl Iterator for Integrate {
    type Item = ();
    fn next(&amp;mut self) -&gt; Option&lt;Self::Item&gt; {
        let gain = self.gain;
        self.y.iter_mut().zip(self.u.iter()).for_each(|(a, v)| {
            *a += *v * gain;
        });
        Some(())
    }
}

<span class="boring">use dosio::{io::jar, DOSIOSError, Dos, IO};
</span><span class="boring">
</span><span class="boring">impl Dos for Integrate {
</span><span class="boring">    type Input = Vec&lt;f64&gt;;
</span><span class="boring">    type Output = Vec&lt;f64&gt;;
</span><span class="boring">    fn inputs(&amp;mut self, data: Option&lt;Vec&lt;IO&lt;Self::Input&gt;&gt;&gt;) -&gt; Result&lt;&amp;mut Self, DOSIOSError&gt; {
</span><span class="boring">        self.u = data
</span><span class="boring">            // Identifying M2 42 segment rigid body motion IO variant
</span><span class="boring">            .and_then(|data| {
</span><span class="boring">                data.into_iter().find_map(|io| match io {
</span><span class="boring">                    IO::MCM2RB6D { data: value } =&gt; value,
</span><span class="boring">                    _ =&gt; None,
</span><span class="boring">                })
</span><span class="boring">            })
</span><span class="boring">            // Extracting M2 14 Rx and Ry rigid body motions
</span><span class="boring">            .map(|x| {
</span><span class="boring">                x.chunks(6)
</span><span class="boring">                    .flat_map(|x| x[3..5].to_vec())
</span><span class="boring">                    .collect::&lt;Vec&lt;f64&gt;&gt;()
</span><span class="boring">            })
</span><span class="boring">            // Throwing an error if IO::MCM2RB6D is missing
</span><span class="boring">            .ok_or_else(|| DOSIOSError::Inputs(&quot;Integrate MCM2RB6D IO input error&quot;.into()))?;
</span><span class="boring">        Ok(self)
</span><span class="boring">    }
</span><span class="boring">    fn outputs(&amp;mut self) -&gt; Option&lt;Vec&lt;IO&lt;Self::Output&gt;&gt;&gt; {
</span><span class="boring">        self.output()
</span><span class="boring">            // Assigning M2 segment Rx and Ry to rigid body motion vector
</span><span class="boring">            .map(|y| {
</span><span class="boring">                y.chunks(2)
</span><span class="boring">                    .flat_map(|y| vec![0f64, 0f64, 0f64, y[0], y[1], 0f64])
</span><span class="boring">                    .collect::&lt;Vec&lt;f64&gt;&gt;()
</span><span class="boring">            })
</span><span class="boring">            // Embedding the rigid body motions into the corresponding IO variant
</span><span class="boring">            .map(|x| vec![jar::MCM2RB6D::io_with(x)])
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">fn main() -&gt; Result&lt;(), Box&lt;dyn std::error::Error&gt;&gt; {
</span><span class="boring">    // Integrator controller
</span><span class="boring">    let mut integrator = Integrate::new(0.5, 14);
</span><span class="boring">    // M2 rigid body motions to DOS input
</span><span class="boring">    let mut m2_rbm = vec![vec![0f64; 6]; 7];
</span><span class="boring">    m2_rbm[0][3] = 1f64; // Segment #1: Rx
</span><span class="boring">    let dos_in = vec![jar::MCM2RB6D::io_with(
</span><span class="boring">        m2_rbm.into_iter().flatten().collect::&lt;Vec&lt;f64&gt;&gt;(),
</span><span class="boring">    )];
</span><span class="boring">    // DOS stepping
</span><span class="boring">    let dos_out = integrator.inputs(Some(dos_in))?.step()?.outputs();
</span><span class="boring">    // or equivalently:
</span><span class="boring">    // let dos_out = integrator.in_step_out(Some(dos_in))?;
</span><span class="boring">    println!(&quot;DOS output:&quot;);
</span><span class="boring">    println!(&quot;{:#?}&quot;, dos_out);
</span><span class="boring">    Ok(())
</span><span class="boring">}
</span></code></pre>
<p>Next, we add the crate <code>dosio</code> as a project dependency:</p>
<pre><code class="language-toml">[package]
name = &quot;ch01-02-dos-api&quot;
version = &quot;0.1.0&quot;
authors = [&quot;Rod Conan &lt;rconan@gmto.org&gt;&quot;]
edition = &quot;2018&quot;

[dependencies]
dosio = { git = &quot;https://github.com/rconan/dosio.git&quot;, branch = &quot;main&quot; }

</code></pre>
<p>and we implement the <code>Dos</code> trait for <code>Integrate</code>:</p>
<pre><code class="language-rust ignore"><span class="boring">#[derive(Default)]
</span><span class="boring">pub struct Integrate {
</span><span class="boring">    /// integrator gain
</span><span class="boring">    gain: f64,
</span><span class="boring">    /// output vector
</span><span class="boring">    y: Vec&lt;f64&gt;,
</span><span class="boring">    /// input vector
</span><span class="boring">    u: Vec&lt;f64&gt;,
</span><span class="boring">}
</span><span class="boring">impl Integrate {
</span><span class="boring">    pub fn new(gain: f64, n_data: usize) -&gt; Self {
</span><span class="boring">        Self {
</span><span class="boring">            gain,
</span><span class="boring">            y: vec![0f64; n_data],
</span><span class="boring">            ..Default::default()
</span><span class="boring">        }
</span><span class="boring">    }
</span><span class="boring">    pub fn output(&amp;self) -&gt; Option&lt;Vec&lt;f64&gt;&gt; {
</span><span class="boring">        Some(self.y.clone())
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">impl Iterator for Integrate {
</span><span class="boring">    type Item = ();
</span><span class="boring">    fn next(&amp;mut self) -&gt; Option&lt;Self::Item&gt; {
</span><span class="boring">        let gain = self.gain;
</span><span class="boring">        self.y.iter_mut().zip(self.u.iter()).for_each(|(a, v)| {
</span><span class="boring">            *a += *v * gain;
</span><span class="boring">        });
</span><span class="boring">        Some(())
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span>use dosio::{io::jar, DOSIOSError, Dos, IO};

impl Dos for Integrate {
    type Input = Vec&lt;f64&gt;;
    type Output = Vec&lt;f64&gt;;
    fn inputs(&amp;mut self, data: Option&lt;Vec&lt;IO&lt;Self::Input&gt;&gt;&gt;) -&gt; Result&lt;&amp;mut Self, DOSIOSError&gt; {
        self.u = data
            // Identifying M2 42 segment rigid body motion IO variant
            .and_then(|data| {
                data.into_iter().find_map(|io| match io {
                    IO::MCM2RB6D { data: value } =&gt; value,
                    _ =&gt; None,
                })
            })
            // Extracting M2 14 Rx and Ry rigid body motions
            .map(|x| {
                x.chunks(6)
                    .flat_map(|x| x[3..5].to_vec())
                    .collect::&lt;Vec&lt;f64&gt;&gt;()
            })
            // Throwing an error if IO::MCM2RB6D is missing
            .ok_or_else(|| DOSIOSError::Inputs(&quot;Integrate MCM2RB6D IO input error&quot;.into()))?;
        Ok(self)
    }
    fn outputs(&amp;mut self) -&gt; Option&lt;Vec&lt;IO&lt;Self::Output&gt;&gt;&gt; {
        self.output()
            // Assigning M2 segment Rx and Ry to rigid body motion vector
            .map(|y| {
                y.chunks(2)
                    .flat_map(|y| vec![0f64, 0f64, 0f64, y[0], y[1], 0f64])
                    .collect::&lt;Vec&lt;f64&gt;&gt;()
            })
            // Embedding the rigid body motions into the corresponding IO variant
            .map(|x| vec![jar::MCM2RB6D::io_with(x)])
    }
}
<span class="boring">
</span><span class="boring">fn main() -&gt; Result&lt;(), Box&lt;dyn std::error::Error&gt;&gt; {
</span><span class="boring">    // Integrator controller
</span><span class="boring">    let mut integrator = Integrate::new(0.5, 14);
</span><span class="boring">    // M2 rigid body motions to DOS input
</span><span class="boring">    let mut m2_rbm = vec![vec![0f64; 6]; 7];
</span><span class="boring">    m2_rbm[0][3] = 1f64; // Segment #1: Rx
</span><span class="boring">    let dos_in = vec![jar::MCM2RB6D::io_with(
</span><span class="boring">        m2_rbm.into_iter().flatten().collect::&lt;Vec&lt;f64&gt;&gt;(),
</span><span class="boring">    )];
</span><span class="boring">    // DOS stepping
</span><span class="boring">    let dos_out = integrator.inputs(Some(dos_in))?.step()?.outputs();
</span><span class="boring">    // or equivalently:
</span><span class="boring">    // let dos_out = integrator.in_step_out(Some(dos_in))?;
</span><span class="boring">    println!(&quot;DOS output:&quot;);
</span><span class="boring">    println!(&quot;{:#?}&quot;, dos_out);
</span><span class="boring">    Ok(())
</span><span class="boring">}
</span></code></pre>
<p>Now we can write the main function:</p>
<pre><code class="language-rust ignore"><span class="boring">#[derive(Default)]
</span><span class="boring">pub struct Integrate {
</span><span class="boring">    /// integrator gain
</span><span class="boring">    gain: f64,
</span><span class="boring">    /// output vector
</span><span class="boring">    y: Vec&lt;f64&gt;,
</span><span class="boring">    /// input vector
</span><span class="boring">    u: Vec&lt;f64&gt;,
</span><span class="boring">}
</span><span class="boring">impl Integrate {
</span><span class="boring">    pub fn new(gain: f64, n_data: usize) -&gt; Self {
</span><span class="boring">        Self {
</span><span class="boring">            gain,
</span><span class="boring">            y: vec![0f64; n_data],
</span><span class="boring">            ..Default::default()
</span><span class="boring">        }
</span><span class="boring">    }
</span><span class="boring">    pub fn output(&amp;self) -&gt; Option&lt;Vec&lt;f64&gt;&gt; {
</span><span class="boring">        Some(self.y.clone())
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">impl Iterator for Integrate {
</span><span class="boring">    type Item = ();
</span><span class="boring">    fn next(&amp;mut self) -&gt; Option&lt;Self::Item&gt; {
</span><span class="boring">        let gain = self.gain;
</span><span class="boring">        self.y.iter_mut().zip(self.u.iter()).for_each(|(a, v)| {
</span><span class="boring">            *a += *v * gain;
</span><span class="boring">        });
</span><span class="boring">        Some(())
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">use dosio::{io::jar, DOSIOSError, Dos, IO};
</span><span class="boring">
</span><span class="boring">impl Dos for Integrate {
</span><span class="boring">    type Input = Vec&lt;f64&gt;;
</span><span class="boring">    type Output = Vec&lt;f64&gt;;
</span><span class="boring">    fn inputs(&amp;mut self, data: Option&lt;Vec&lt;IO&lt;Self::Input&gt;&gt;&gt;) -&gt; Result&lt;&amp;mut Self, DOSIOSError&gt; {
</span><span class="boring">        self.u = data
</span><span class="boring">            // Identifying M2 42 segment rigid body motion IO variant
</span><span class="boring">            .and_then(|data| {
</span><span class="boring">                data.into_iter().find_map(|io| match io {
</span><span class="boring">                    IO::MCM2RB6D { data: value } =&gt; value,
</span><span class="boring">                    _ =&gt; None,
</span><span class="boring">                })
</span><span class="boring">            })
</span><span class="boring">            // Extracting M2 14 Rx and Ry rigid body motions
</span><span class="boring">            .map(|x| {
</span><span class="boring">                x.chunks(6)
</span><span class="boring">                    .flat_map(|x| x[3..5].to_vec())
</span><span class="boring">                    .collect::&lt;Vec&lt;f64&gt;&gt;()
</span><span class="boring">            })
</span><span class="boring">            // Throwing an error if IO::MCM2RB6D is missing
</span><span class="boring">            .ok_or_else(|| DOSIOSError::Inputs(&quot;Integrate MCM2RB6D IO input error&quot;.into()))?;
</span><span class="boring">        Ok(self)
</span><span class="boring">    }
</span><span class="boring">    fn outputs(&amp;mut self) -&gt; Option&lt;Vec&lt;IO&lt;Self::Output&gt;&gt;&gt; {
</span><span class="boring">        self.output()
</span><span class="boring">            // Assigning M2 segment Rx and Ry to rigid body motion vector
</span><span class="boring">            .map(|y| {
</span><span class="boring">                y.chunks(2)
</span><span class="boring">                    .flat_map(|y| vec![0f64, 0f64, 0f64, y[0], y[1], 0f64])
</span><span class="boring">                    .collect::&lt;Vec&lt;f64&gt;&gt;()
</span><span class="boring">            })
</span><span class="boring">            // Embedding the rigid body motions into the corresponding IO variant
</span><span class="boring">            .map(|x| vec![jar::MCM2RB6D::io_with(x)])
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span>fn main() -&gt; Result&lt;(), Box&lt;dyn std::error::Error&gt;&gt; {
    // Integrator controller
    let mut integrator = Integrate::new(0.5, 14);
    // M2 rigid body motions to DOS input
    let mut m2_rbm = vec![vec![0f64; 6]; 7];
    m2_rbm[0][3] = 1f64; // Segment #1: Rx
    let dos_in = vec![jar::MCM2RB6D::io_with(
        m2_rbm.into_iter().flatten().collect::&lt;Vec&lt;f64&gt;&gt;(),
    )];
    // DOS stepping
    let dos_out = integrator.inputs(Some(dos_in))?.step()?.outputs();
    // or equivalently:
    // let dos_out = integrator.in_step_out(Some(dos_in))?;
    println!(&quot;DOS output:&quot;);
    println!(&quot;{:#?}&quot;, dos_out);
    Ok(())
}
</code></pre>
<h1 id="optical-model"><a class="header" href="#optical-model">Optical Model</a></h1>
<p>The GMT optical model defines the optical prescriptions of the GMT primary and secondary mirrors along with the functionnalities to perform ray tracing through the telescope down to the exit pupil.
Fourier optics based optical sensor models transform the wavefront in the telescope exit pupil into either a focal plane image, Shack-Hartmann subaperture images  or a pyramid four-quadrant pupil image, for example.
Noise can be added to the sensor images by the mean of a detector noise model.</p>
<p>At the core of the optical model is <a href="https://github.com/rconan/CEO">CEO</a>, a GPU optics simulator written in C++ using the CUDA API. 
A Rust binding for CEO is provided by the crate <a href="https://github.com/rconan/crseo">crseo</a>, that makes all the functionalities of CEO available through an idiomatic RUST API.
<a href="https://rconan.github.io/crseo">crseo</a> provides an implementation of the DOS Rust interface allowing to seamlessly integrate CEO with the GMT Dynamics Optics Simulation framework.</p>
<h2 id="installation-1"><a class="header" href="#installation-1">Installation</a></h2>
<p>CEO compiles only on a machine with a NVIDIA GPU installed and with the CUDA API present. 
CEO installation steps are given <a href="https://github.com/rconan/CEO">here</a>.</p>
<p>CEO bindings crate <code>crseo</code>, needs to be added to the dependencies list in the <em>Cargo.toml</em> file of your project, both the <code>dosio</code> crate and the <code>dos</code> feature of <code>crseo</code> are required in order to compile the <em>Dos</em> interface:</p>
<pre><code class="language-toml">dosio = { git = &quot;https://github.com/rconan/dosio.git&quot;, branch = &quot;main&quot; }
# should be the git url, but with the git repo, CEO does not compile? 
crseo = { path = &quot;/home/rconan/projects/crseo&quot; , features = [&quot;dos&quot;]}
#crseo = { git = &quot;https://github.com/rconan/crseo.git&quot;, branch = &quot;main&quot;, features = [&quot;dos&quot;] }
</code></pre>
<h2 id="dos-interface-1"><a class="header" href="#dos-interface-1">DOS Interface</a></h2>
<p>The <em>DOS</em> interface for the optical model is implemented for 2 structures: <code>GmtOpticalModelInner</code> and <code>GmtOpticalSensorModelInner</code>.
<code>GmtOpticalModelInner</code> only performs ray tracing through the telescope and <code>GmtOpticalSensorModelInner</code> appends an optical sensor to the model,  Fourier propagating the wavefront derived from ray tracing to the sensor image plane. 
Both allows to alter the state of the M1 and M2 segment rigid body motions and segment surface figures.</p>
<h3 id="gmt-optical-model"><a class="header" href="#gmt-optical-model">GMT Optical Model</a></h3>
<p>A  <code>GmtOpticalModelInner</code> structure is created with the <a href="https://rconan.github.io/crseo/crseo/dos/struct.GmtOpticalModel.html"><code>GmtOpticalModel</code></a> builder that uses default templates for both the <a href="https://rconan.github.io/crseo/crseo/struct.GMT.html">GMT</a> and the <a href="https://rconan.github.io/crseo/crseo/struct.SOURCE.html">source</a> models.
The outputs of the model need to be specified as well, in the following, the model provides 2 outputs: the wavefront error rms and the PSSn are specified.</p>
<pre><code class="language-rust ignore">use crseo::dos::GmtOpticalModel;
use dosio::{io::jar, Dos};

fn main() -&gt; std::result::Result&lt;(), Box&lt;dyn std::error::Error&gt;&gt; {
    let mut gom = GmtOpticalModel::new()
        .output(jar::SrcWfeRms::io())
        .output(jar::Pssn::io())
        .build()?;
    println!(&quot;M1 mode: {}&quot;, gom.gmt.get_m1_mode_type());
    println!(&quot;M2 mode: {}&quot;, gom.gmt.get_m2_mode_type());
    println!(&quot;GS band: {}&quot;, gom.src.get_photometric_band());
    println!(&quot;Outputs: {:#?}&quot;, gom.outputs);

    let y = gom.in_step_out(None)?;
    println!(&quot;y: {:#?}&quot;, y);

    Ok(())
}
</code></pre>
<h3 id="gmt-optical-sensor-model"><a class="header" href="#gmt-optical-sensor-model">GMT Optical Sensor Model</a></h3>
<p>A  <code>GmtOpticalModeSensorlInner</code> structure is created with the <a href="https://rconan.github.io/crseo/crseo/dos/sensor/struct.GmtOpticalSensorModel.html"><code>GmtOpticalSensorModel</code></a> builder that uses default templates for the <a href="https://rconan.github.io/crseo/crseo/struct.GMT.html">GMT</a>, the <a href="https://rconan.github.io/crseo/crseo/struct.SOURCE.html">source</a> and the optical sensor models.
In the following, the optical sensor is based on the <a href="https://rconan.github.io/crseo/crseo/shackhartmann/struct.SH48.html">SH48</a> template but reduced to a single sensor.
The model has a single output: the data from the optical sensor.</p>
<pre><code class="language-rust ignore">use crseo::dos::GmtOpticalSensorModel;
use crseo::{shackhartmann::Geometric as WFS_TYPE, Builder, ShackHartmann, SH48};
use dosio::{io::jar, Dos};

fn main() -&gt; std::result::Result&lt;(), Box&lt;dyn std::error::Error&gt;&gt; {
    let mut gosm = GmtOpticalSensorModel::&lt;ShackHartmann&lt;WFS_TYPE&gt;, SH48&lt;WFS_TYPE&gt;&gt;::new()
        .sensor(SH48::&lt;WFS_TYPE&gt;::new().n_sensor(1))
        .build()?;
    println!(&quot;M1 mode: {}&quot;, gosm.gmt.get_m1_mode_type());
    println!(&quot;M2 mode: {}&quot;, gosm.gmt.get_m2_mode_type());
    println!(&quot;GS band: {}&quot;, gosm.src.get_photometric_band());

    let y = gosm.in_step_out(None)?.unwrap();
    let sensor_data: Option&lt;Vec&lt;f64&gt;&gt; = (&amp;y[jar::SensorData::io::&lt;Vec&lt;f64&gt;&gt;()]).into();
    println!(&quot;sensor data size: {:}&quot;, sensor_data.unwrap().len());

    Ok(())
}
</code></pre>
<h1 id="finite-element-model"><a class="header" href="#finite-element-model">Finite Element Model</a></h1>
<p>The finite element model (FEM) is a second order coupled set of differential equations that models the dynamic behavior of the telescope mechanical structure subject to forces and moments applied to a discrete set of nodes on the telescope.
The FEM used in the DOS has been decomposed into its eigen modes, each mode representing a unique dynamic resonance of the telescope at a particular eigen frequency.
In the space of the eigen modes, the FEM is reduced to a set of second order <strong>decoupled</strong> differential equations</p>
<p>The FEM is modeled with the crate <a href="https://github.com/rconan/fem">fem</a> allowing to import the data exported from a FEM solver and to convert the data into a discrete dynamic model with a <em>Dos</em> interface.</p>
<h2 id="installation-2"><a class="header" href="#installation-2">Installation</a></h2>
<p>Both the crates <code>dosio</code> and <code>fem</code> needs to be added to the dependencies list in the <em>Cargo.toml</em> file of your project, the features <em>dos</em> of the <code>fem</code> is required to compile the <em>Dos</em> interface.</p>
<pre><code class="language-toml">dosio = { git = &quot;https://github.com/rconan/dosio.git&quot;, branch = &quot;main&quot; }
fem = { path = &quot;/home/rconan/projects/fem&quot;, features = [&quot;dos&quot;] }
simple_logger = &quot;1.11.0&quot;
</code></pre>
<h2 id="dos-interface-2"><a class="header" href="#dos-interface-2">Dos Interface</a></h2>
<p>In the following, the FEM is discretized with a 1kHz sampling rate, the modal damping coefficient is set to 2% and the eigen frequencies are truncated at 75Hz.
Inputs are reduced to the wind loads of the M1 segments and the outputs are the rigid body motions of M1 and M2 segments.</p>
<pre><code class="language-rust ignore"><span class="boring">use dosio::{io::jar, Dos};
</span><span class="boring">use fem::{dos::DiscreteStateSpace, FEM};
</span><span class="boring">use simple_logger::SimpleLogger;
</span><span class="boring">use std::path::Path;
</span><span class="boring">use std::time::Instant;
</span><span class="boring">
</span><span class="boring">fn main() -&gt; Result&lt;(), Box&lt;dyn std::error::Error&gt;&gt; {
</span><span class="boring">    SimpleLogger::new().init()?;
</span>    let fem_data_path = Path::new(&quot;data&quot;).join(&quot;20210225_1447_MT_mount_v202102_ASM_wind2&quot;);
    let sampling_rate = 1e3;
    let m1_rbm_io = jar::OSSM1Lcl::io();
    let m2_rbm_io = jar::MCM2RB6D::io();
    let mut fem = {
        let fem = FEM::from_pickle(fem_data_path.join(&quot;modal_state_space_model_2ndOrder.73.pkl&quot;))?;
        DiscreteStateSpace::from(fem)
    }
    .sampling(sampling_rate)
    .proportional_damping(2. / 100.)
    .max_eigen_frequency(75.0)
    .inputs(vec![jar::OSSM1Lcl6F::io()])
    .outputs(vec![m1_rbm_io.clone(), m2_rbm_io.clone()])
    .build()?;
    println!(
        &quot;Dynamic discrete FEM: {} 2x2 state space model&quot;,
        fem.state_space.len()
    );
<span class="boring">
</span><span class="boring">    let m1_wind_loads = {
</span><span class="boring">        let mut u = vec![0f64; 42];
</span><span class="boring">        u.chunks_mut(6).for_each(|u| u[0] = 100f64);
</span><span class="boring">        jar::OSSM1Lcl6F::io_with(u)
</span><span class="boring">    };
</span><span class="boring">
</span><span class="boring">    // vector norm
</span><span class="boring">    let norm = |x: Option&lt;Vec&lt;f64&gt;&gt;| -&gt; f64 {
</span><span class="boring">        x.as_ref()
</span><span class="boring">            .unwrap()
</span><span class="boring">            .iter()
</span><span class="boring">            .fold(0., |s, &amp;x| s + x * x)
</span><span class="boring">            .sqrt()
</span><span class="boring">    };
</span><span class="boring">
</span><span class="boring">    let now = Instant::now();
</span><span class="boring">    println!(&quot;{:^03} {:^8} {:^8}&quot;, &quot;#&quot;, &quot;M1&quot;, &quot;M2&quot;);
</span><span class="boring">    for k in 0..20 {
</span><span class="boring">        let y = fem.in_step_out(Some(vec![m1_wind_loads.clone()]))?.unwrap();
</span><span class="boring">        let m1_rbm = norm((&amp;y[m1_rbm_io.clone()]).into());
</span><span class="boring">        let m2_rbm = norm((&amp;y[m2_rbm_io.clone()]).into());
</span><span class="boring">        println!(&quot;{:&lt;03} {:&lt;8.3e} {:&lt;8.3e}&quot;, k, m1_rbm, m2_rbm);
</span><span class="boring">    }
</span><span class="boring">    println!(&quot;Elapsed time: {:}ms&quot;, now.elapsed().as_millis());
</span><span class="boring">
</span><span class="boring">    Ok(())
</span><span class="boring">}
</span></code></pre>
<p>A constant wind pressure is applied to the M1 segments and the norm of the rigid body motion vectors is computed.</p>
<pre><code class="language-rust ignore"><span class="boring">use dosio::{io::jar, Dos};
</span><span class="boring">use fem::{dos::DiscreteStateSpace, FEM};
</span><span class="boring">use simple_logger::SimpleLogger;
</span><span class="boring">use std::path::Path;
</span><span class="boring">use std::time::Instant;
</span><span class="boring">
</span><span class="boring">fn main() -&gt; Result&lt;(), Box&lt;dyn std::error::Error&gt;&gt; {
</span><span class="boring">    SimpleLogger::new().init()?;
</span><span class="boring">    let fem_data_path = Path::new(&quot;data&quot;).join(&quot;20210225_1447_MT_mount_v202102_ASM_wind2&quot;);
</span><span class="boring">    let sampling_rate = 1e3;
</span><span class="boring">    let m1_rbm_io = jar::OSSM1Lcl::io();
</span><span class="boring">    let m2_rbm_io = jar::MCM2RB6D::io();
</span><span class="boring">    let mut fem = {
</span><span class="boring">        let fem = FEM::from_pickle(fem_data_path.join(&quot;modal_state_space_model_2ndOrder.73.pkl&quot;))?;
</span><span class="boring">        DiscreteStateSpace::from(fem)
</span><span class="boring">    }
</span><span class="boring">    .sampling(sampling_rate)
</span><span class="boring">    .proportional_damping(2. / 100.)
</span><span class="boring">    .max_eigen_frequency(75.0)
</span><span class="boring">    .inputs(vec![jar::OSSM1Lcl6F::io()])
</span><span class="boring">    .outputs(vec![m1_rbm_io.clone(), m2_rbm_io.clone()])
</span><span class="boring">    .build()?;
</span><span class="boring">    println!(
</span><span class="boring">        &quot;Dynamic discrete FEM: {} 2x2 state space model&quot;,
</span><span class="boring">        fem.state_space.len()
</span><span class="boring">    );
</span><span class="boring">
</span><span class="boring">    let m1_wind_loads = {
</span><span class="boring">        let mut u = vec![0f64; 42];
</span><span class="boring">        u.chunks_mut(6).for_each(|u| u[0] = 100f64);
</span><span class="boring">        jar::OSSM1Lcl6F::io_with(u)
</span><span class="boring">    };
</span><span class="boring">
</span>    // vector norm
    let norm = |x: Option&lt;Vec&lt;f64&gt;&gt;| -&gt; f64 {
        x.as_ref()
            .unwrap()
            .iter()
            .fold(0., |s, &amp;x| s + x * x)
            .sqrt()
    };

    let now = Instant::now();
    println!(&quot;{:^03} {:^8} {:^8}&quot;, &quot;#&quot;, &quot;M1&quot;, &quot;M2&quot;);
    for k in 0..20 {
        let y = fem.in_step_out(Some(vec![m1_wind_loads.clone()]))?.unwrap();
        let m1_rbm = norm((&amp;y[m1_rbm_io.clone()]).into());
        let m2_rbm = norm((&amp;y[m2_rbm_io.clone()]).into());
        println!(&quot;{:&lt;03} {:&lt;8.3e} {:&lt;8.3e}&quot;, k, m1_rbm, m2_rbm);
    }
    println!(&quot;Elapsed time: {:}ms&quot;, now.elapsed().as_millis());
<span class="boring">
</span><span class="boring">    Ok(())
</span><span class="boring">}
</span></code></pre>
<h1 id="wind-loading"><a class="header" href="#wind-loading">Wind Loading</a></h1>
<p>The <a href="https://github.com/rconan/windloading">windloading</a> crate loads the time series of forces and moments computed with the CFD simulations and allocates them to different <code>IO</code> enum variants of the <em>Dos</em> interface. 
The wind loads can be applied on the following components of the FEM:</p>
<ul>
<li>the top-end,</li>
<li>the M2 ASMs top-end,</li>
<li>the M2 segments,</li>
<li>the M2 ASMs reference bodies,</li>
<li>the trusses,</li>
<li>the M1 segments,</li>
<li>the M1 cells,</li>
<li>the GIR,</li>
<li>the C-Ring.</li>
</ul>
<h2 id="installation-3"><a class="header" href="#installation-3">Installation</a></h2>
<p>Both the crates <code>dosio</code> and <code>windloading</code> needs to be added to the dependencies list in the <em>Cargo.toml</em> file of your project.</p>
<pre><code class="language-toml">dosio = { git = &quot;https://github.com/rconan/dosio.git&quot;, branch = &quot;main&quot; }
windloading = { git = &quot;https://github.com/rconan/windloading.git&quot;, branch = &quot;main&quot; }
</code></pre>
<h2 id="dos-interface-3"><a class="header" href="#dos-interface-3">Dos Interface</a></h2>
<p>From one CFD case, the wind loads time series are resampled to the sampling rate of a <em>Dos</em> simulation and saved into a Pickle file to be re-played later.
The wind loads are then loaded into the simulation and the wind loads to use with the simulation are selected according to the telescope structural component they are applied to.</p>
<pre><code class="language-rust ignore"><span class="boring">use dosio::{Dos, IOTags};
</span><span class="boring">use std::path::Path;
</span><span class="boring">use std::time::Instant;
</span><span class="boring">use windloading::WindLoads;
</span><span class="boring">
</span><span class="boring">fn main() -&gt; Result&lt;(), Box&lt;dyn std::error::Error&gt;&gt; {
</span>    println!(&quot;Loading the wind loads ...&quot;);
    let now = Instant::now();
    let fem_data_path = Path::new(&quot;data&quot;).join(&quot;20210225_1447_MT_mount_v202102_ASM_wind2&quot;);
    let mut wind_loading = WindLoads::from_pickle(
        fem_data_path.join(&quot;b2019_0z_30az_os_7ms.wind_loads_1kHz_100-400s.pkl&quot;),
    )?
    .range(0.0, 20.0)
    .truss()?
    .m2_asm_topend()?
    .m1_segments()?
    .m1_cell()?
    .m2_asm_reference_bodies()?
    .build()?;
    println!(&quot;Wind loads loaded in {}ms&quot;, now.elapsed().as_millis());
    println!(&quot;wind loads outputs: {:#?}&quot;, wind_loading.outputs_tags());
<span class="boring">    println!(&quot;Playing the wind loads ...&quot;);
</span><span class="boring">    let now = Instant::now();
</span><span class="boring">    while let Some(_fem_forces) = wind_loading.outputs() {}
</span><span class="boring">    println!(
</span><span class="boring">        &quot;{} sample wind loads played in {}ms&quot;,
</span><span class="boring">        wind_loading.n_sample,
</span><span class="boring">        now.elapsed().as_millis()
</span><span class="boring">    );
</span><span class="boring">    Ok(())
</span><span class="boring">}
</span></code></pre>
<p>The <a href="https://rconan.github.io/windloading"><code>windloading</code></a> crate implements only the <code>outputs</code> method of the <em>Dos</em> interface stepping through the time series of forces and moments at each call and returning <code>None</code> when the range limit has been reached.</p>
<pre><code class="language-rust ignore"><span class="boring">use dosio::{Dos, IOTags};
</span><span class="boring">use std::path::Path;
</span><span class="boring">use std::time::Instant;
</span><span class="boring">use windloading::WindLoads;
</span><span class="boring">
</span><span class="boring">fn main() -&gt; Result&lt;(), Box&lt;dyn std::error::Error&gt;&gt; {
</span><span class="boring">    println!(&quot;Loading the wind loads ...&quot;);
</span><span class="boring">    let now = Instant::now();
</span><span class="boring">    let fem_data_path = Path::new(&quot;data&quot;).join(&quot;20210225_1447_MT_mount_v202102_ASM_wind2&quot;);
</span><span class="boring">    let mut wind_loading = WindLoads::from_pickle(
</span><span class="boring">        fem_data_path.join(&quot;b2019_0z_30az_os_7ms.wind_loads_1kHz_100-400s.pkl&quot;),
</span><span class="boring">    )?
</span><span class="boring">    .range(0.0, 20.0)
</span><span class="boring">    .truss()?
</span><span class="boring">    .m2_asm_topend()?
</span><span class="boring">    .m1_segments()?
</span><span class="boring">    .m1_cell()?
</span><span class="boring">    .m2_asm_reference_bodies()?
</span><span class="boring">    .build()?;
</span><span class="boring">    println!(&quot;Wind loads loaded in {}ms&quot;, now.elapsed().as_millis());
</span><span class="boring">    println!(&quot;wind loads outputs: {:#?}&quot;, wind_loading.outputs_tags());
</span>    println!(&quot;Playing the wind loads ...&quot;);
    let now = Instant::now();
    while let Some(_fem_forces) = wind_loading.outputs() {}
    println!(
        &quot;{} sample wind loads played in {}ms&quot;,
        wind_loading.n_sample,
        now.elapsed().as_millis()
    );
<span class="boring">    Ok(())
</span><span class="boring">}
</span></code></pre>
<h1 id="controllers"><a class="header" href="#controllers">Controllers</a></h1>
<p>The GMT has multiple controllers connecting sensors and actuators distributed across the telescope.
From a programming perspective, there are 2 categories of controllers:</p>
<ul>
<li>controllers that are implemented using Simulink, converted to C and binded to Rust,</li>
<li>and controllers that are implemented directly in Rust.</li>
</ul>
<h2 id="simulink"><a class="header" href="#simulink">Simulink</a></h2>
<p>For the controllers that are implemented with Simulink, the crate <a href="https://github.com/rconan/simulink-rs.git">simulink-rs</a> provides <a href="https://rconan.github.io/simulink-rs">macros</a> to define the Rust binding interface to the C conversions of the Simulink controllers.</p>
<p>Using the <code>simulink-rs</code> crate, the following GMT controllers have been implemented in Rust and each of them also implements the <em>Dos</em> interface: </p>
<ul>
<li>the GMT <a href="https://github.com/rconan/mount-ctrl.git">mount control system</a>.</li>
<li>the GMT <a href="https://github.com/rconan/m1-ctrl.git">M1 control system</a>.</li>
</ul>
<p>In the following model example, we combine together the FEM, the wind loads and both the mount and M1 control systems.</p>
<p>The model starts by adding the crates 
<a href="https://github.com/rconan/dosio.git">dosio</a>,
<a href="https://github.com/rconan/fem.git">fem</a>,
<a href="https://github.com/rconan/m1-ctrl.git">m1-ctrl</a>,
<a href="https://github.com/rconan/mount-ctrl.git">mount-ctrl</a> and
<a href="https://github.com/rconan/windloading.git">windloading</a>
to the list of dependencies in <em>Cargo.toml</em>.</p>
<pre><code class="language-toml">dosio = { git = &quot;https://github.com/rconan/dosio.git&quot;, branch = &quot;main&quot; }
fem = { git = &quot;https://github.com/rconan/fem.git&quot;, branch = &quot;dos&quot;, features = [&quot;dos&quot;] }
m1-ctrl = { git = &quot;https://github.com/rconan/m1-ctrl.git&quot;, branch = &quot;main&quot; }
mount-ctrl = { git = &quot;https://github.com/rconan/mount-ctrl.git&quot;, branch = &quot;main&quot; }
simple_logger = &quot;1.11.0&quot;
windloading = { git = &quot;https://github.com/rconan/windloading.git&quot;, branch = &quot;main&quot; }
</code></pre>
<p>Then the model is laid out in <em>src/main.rs</em> with</p>
<ul>
<li>the FEM, sampled at 1kHz, with a 2% proportionnal damping coefficient and a maximum eigen fequency of 75Hz; the inputs are the windloads and the mount drives; the outputs are the mount encoders, M1 hardpoints and M1 and M2 rigid body motions:</li>
</ul>
<pre><code class="language-rust ignore"><span class="boring">use dosio::{io::jar::*, io::IO, Dos};
</span><span class="boring">use fem::{dos::DiscreteStateSpace, FEM};
</span><span class="boring">use m1_ctrl as m1;
</span><span class="boring">use mount_ctrl as mount;
</span><span class="boring">//use serde_pickle as pkl;
</span><span class="boring">use simple_logger::SimpleLogger;
</span><span class="boring">use windloading::WindLoads;
</span><span class="boring">//use std::error::Error;
</span><span class="boring">use std::path::Path;
</span><span class="boring">use std::time::Instant;
</span><span class="boring">//use std::{fs::File, io::Error};
</span><span class="boring">
</span><span class="boring">struct Timer {
</span><span class="boring">    time: Instant,
</span><span class="boring">}
</span><span class="boring">impl Timer {
</span><span class="boring">    pub fn tic() -&gt; Self {
</span><span class="boring">        Self {
</span><span class="boring">            time: Instant::now(),
</span><span class="boring">        }
</span><span class="boring">    }
</span><span class="boring">    pub fn toc(self) -&gt; f64 {
</span><span class="boring">        self.time.elapsed().as_secs_f64()
</span><span class="boring">    }
</span><span class="boring">    pub fn print_toc(self) {
</span><span class="boring">        println!(&quot;... in {:3}s&quot;, self.toc());
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">fn main() -&gt; Result&lt;(), Box&lt;dyn std::error::Error&gt;&gt; {
</span><span class="boring">    SimpleLogger::new().init().unwrap();
</span><span class="boring">    let fem_data_path = Path::new(&quot;data&quot;).join(&quot;20210225_1447_MT_mount_v202102_ASM_wind2&quot;);
</span><span class="boring">    // WIND LOADS
</span><span class="boring">    let tic = Timer::tic();
</span><span class="boring">    println!(&quot;Loading wind loads ...&quot;);
</span><span class="boring">    let mut wind_loading = WindLoads::from_pickle(
</span><span class="boring">        fem_data_path.join(&quot;b2019_0z_30az_os_7ms.wind_loads_1kHz_100-400s.pkl&quot;),
</span><span class="boring">    )?
</span><span class="boring">    .range(0.0, 20.0)
</span><span class="boring">    .truss()?
</span><span class="boring">    .m2_asm_topend()?
</span><span class="boring">    .m1_segments()?
</span><span class="boring">    .m1_cell()?
</span><span class="boring">    .m2_asm_reference_bodies()?
</span><span class="boring">    .build()?;
</span><span class="boring">    tic.print_toc();
</span><span class="boring">
</span><span class="boring">    // MOUNT CONTROL
</span><span class="boring">    let mut mnt_drives = mount::drives::Controller::new();
</span><span class="boring">    let mut mnt_ctrl = mount::controller::Controller::new();
</span><span class="boring">
</span><span class="boring">    // M1
</span><span class="boring">    let mut m1_hardpoints = m1::hp_load_cells::Controller::new();
</span><span class="boring">    let mut m1_ctrl = m1::cg_controller::Controller::new();
</span><span class="boring">
</span><span class="boring">    // FEM
</span>    let sampling_rate = 1e3;
    let m1_rbm = OSSM1Lcl::io();
    let m2_rbm = MCM2RB6D::io();
    let tic = Timer::tic();
    println!(&quot;Building FEM dynamic model...&quot;);
    let mut fem = DiscreteStateSpace::from(FEM::from_pickle(
        fem_data_path.join(&quot;modal_state_space_model_2ndOrder.73.pkl&quot;),
    )?)
    .dump_eigen_frequencies(fem_data_path.join(&quot;eigen_frequencies.pkl&quot;))
    .sampling(sampling_rate)
    .proportional_damping(2. / 100.)
    .max_eigen_frequency(75.0)
    .inputs_from(&amp;wind_loading)
    .inputs_from(&amp;mnt_drives)
    .outputs(vec![m1_rbm, m2_rbm])
    .outputs(vec![
        OSSAzEncoderAngle::io(),
        OSSElEncoderAngle::io(),
        OSSRotEncoderAngle::io(),
    ])
    .outputs(vec![OSSHardpointD::io()])
    .build()?;
<span class="boring">    tic.print_toc();
</span><span class="boring">
</span><span class="boring">    // DATA LOGGING
</span><span class="boring">    /*let mut data = DataLogging::new()
</span><span class="boring">    .sampling_rate(sampling_rate)
</span><span class="boring">    //.key(m1_rbm.clone())
</span><span class="boring">    //.key(m2_rbm.clone())
</span><span class="boring">    .build();*/
</span><span class="boring">
</span><span class="boring">    // FEEDBACK LOOP
</span><span class="boring">    println!(&quot;Running model ...&quot;);
</span><span class="boring">    let tic = Timer::tic();
</span><span class="boring">    let mut mount_drives_forces = Some(vec![
</span><span class="boring">        OSSAzDriveTorque::io_with(vec![0f64; 12]),
</span><span class="boring">        OSSElDriveTorque::io_with(vec![0f64; 4]),
</span><span class="boring">        OSSRotDriveTorque::io_with(vec![0f64; 4]),
</span><span class="boring">    ]);
</span><span class="boring">    let mut m1_cg_fm: Option&lt;Vec&lt;IO&lt;Vec&lt;f64&gt;&gt;&gt;&gt; = None;
</span><span class="boring">    let mut k = 0;
</span><span class="boring">    while let Some(mut fem_forces) = wind_loading.outputs() {
</span><span class="boring">        // FEM
</span><span class="boring">        mount_drives_forces.as_mut().map(|x| {
</span><span class="boring">            fem_forces.append(x);
</span><span class="boring">        });
</span><span class="boring">        m1_cg_fm.as_ref().map(|x| {
</span><span class="boring">            fem_forces[OSSM1Lcl6F::io()] += &amp;x[0];
</span><span class="boring">            fem_forces[OSSCellLcl6F::io()] -= &amp;x[0];
</span><span class="boring">        });
</span><span class="boring">        let fem_outputs = fem
</span><span class="boring">            .in_step_out(Some(fem_forces))?
</span><span class="boring">            .ok_or(&quot;FEM output is empty&quot;)?;
</span><span class="boring">        // MOUNT CONTROLLER &amp; DRIVES
</span><span class="boring">        let mount_encoders = &amp;fem_outputs[2..5];
</span><span class="boring">        mount_drives_forces = mnt_ctrl
</span><span class="boring">            .in_step_out(Some(mount_encoders.to_vec()))?
</span><span class="boring">            .map(|mut x| {
</span><span class="boring">                x.extend_from_slice(mount_encoders);
</span><span class="boring">                mnt_drives.in_step_out(Some(x))
</span><span class="boring">            })
</span><span class="boring">            .unwrap()?;
</span><span class="boring">        // M1 HARDPOINT &amp; CG CONTROLLER
</span><span class="boring">        if k % 10 == 0 {
</span><span class="boring">            let mut m1_hp = vec![M1HPCmd::io_with(vec![0f64; 42])];
</span><span class="boring">            m1_hp.extend_from_slice(&amp;[fem_outputs[OSSHardpointD::io::&lt;()&gt;()].clone()]);
</span><span class="boring">            m1_cg_fm = m1_ctrl.in_step_out(m1_hardpoints.in_step_out(Some(m1_hp))?)?;
</span><span class="boring">        }
</span><span class="boring">        k += 1;
</span><span class="boring">    }
</span><span class="boring">    tic.print_toc();
</span><span class="boring">
</span><span class="boring">    // DATA LOGGING
</span><span class="boring">    //data.step()?;
</span><span class="boring">    //data.log(&amp;fem_outputs[0])?.log(&amp;fem_outputs[1])?;
</span><span class="boring">    /*
</span><span class="boring">    // OUTPUTS SAVING
</span><span class="boring">    let mut f = File::create(fem_data_path.join(&quot;mount_control.data.pkl&quot;)).unwrap();
</span><span class="boring">    pkl::to_writer(
</span><span class="boring">        &amp;mut f,
</span><span class="boring">        &amp;[
</span><span class="boring">            data.time_series(m1_rbm),
</span><span class="boring">            data.time_series(m2_rbm),
</span><span class="boring">            //data.time_series(M1HPLC::new()),
</span><span class="boring">            //data.time_series(M1CGFM::new()),
</span><span class="boring">            //data.time_series(OSSAzEncoderAngle::new()),
</span><span class="boring">            //data.time_series(OSSElEncoderAngle::new()),
</span><span class="boring">            //data.time_series(OSSRotEncoderAngle::new()),
</span><span class="boring">            //data.time_series(MountCmd::new()),
</span><span class="boring">        ],
</span><span class="boring">        true,
</span><span class="boring">    )
</span><span class="boring">    .unwrap();
</span><span class="boring">     */
</span><span class="boring">    Ok(())
</span><span class="boring">}
</span></code></pre>
<ul>
<li>the 1st 20s of wind loads on the top-end, the truss, M1 segment, M1 cells and M1 ASM reference bodies:</li>
</ul>
<pre><code class="language-rust ignore"><span class="boring">use dosio::{io::jar::*, io::IO, Dos};
</span><span class="boring">use fem::{dos::DiscreteStateSpace, FEM};
</span><span class="boring">use m1_ctrl as m1;
</span><span class="boring">use mount_ctrl as mount;
</span><span class="boring">//use serde_pickle as pkl;
</span><span class="boring">use simple_logger::SimpleLogger;
</span><span class="boring">use windloading::WindLoads;
</span><span class="boring">//use std::error::Error;
</span><span class="boring">use std::path::Path;
</span><span class="boring">use std::time::Instant;
</span><span class="boring">//use std::{fs::File, io::Error};
</span><span class="boring">
</span><span class="boring">struct Timer {
</span><span class="boring">    time: Instant,
</span><span class="boring">}
</span><span class="boring">impl Timer {
</span><span class="boring">    pub fn tic() -&gt; Self {
</span><span class="boring">        Self {
</span><span class="boring">            time: Instant::now(),
</span><span class="boring">        }
</span><span class="boring">    }
</span><span class="boring">    pub fn toc(self) -&gt; f64 {
</span><span class="boring">        self.time.elapsed().as_secs_f64()
</span><span class="boring">    }
</span><span class="boring">    pub fn print_toc(self) {
</span><span class="boring">        println!(&quot;... in {:3}s&quot;, self.toc());
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">fn main() -&gt; Result&lt;(), Box&lt;dyn std::error::Error&gt;&gt; {
</span><span class="boring">    SimpleLogger::new().init().unwrap();
</span><span class="boring">    let fem_data_path = Path::new(&quot;data&quot;).join(&quot;20210225_1447_MT_mount_v202102_ASM_wind2&quot;);
</span><span class="boring">    // WIND LOADS
</span><span class="boring">    let tic = Timer::tic();
</span>    println!(&quot;Loading wind loads ...&quot;);
    let mut wind_loading = WindLoads::from_pickle(
        fem_data_path.join(&quot;b2019_0z_30az_os_7ms.wind_loads_1kHz_100-400s.pkl&quot;),
    )?
    .range(0.0, 20.0)
    .truss()?
    .m2_asm_topend()?
    .m1_segments()?
    .m1_cell()?
    .m2_asm_reference_bodies()?
    .build()?;
<span class="boring">    tic.print_toc();
</span><span class="boring">
</span><span class="boring">    // MOUNT CONTROL
</span><span class="boring">    let mut mnt_drives = mount::drives::Controller::new();
</span><span class="boring">    let mut mnt_ctrl = mount::controller::Controller::new();
</span><span class="boring">
</span><span class="boring">    // M1
</span><span class="boring">    let mut m1_hardpoints = m1::hp_load_cells::Controller::new();
</span><span class="boring">    let mut m1_ctrl = m1::cg_controller::Controller::new();
</span><span class="boring">
</span><span class="boring">    // FEM
</span><span class="boring">    let sampling_rate = 1e3;
</span><span class="boring">    let m1_rbm = OSSM1Lcl::io();
</span><span class="boring">    let m2_rbm = MCM2RB6D::io();
</span><span class="boring">    let tic = Timer::tic();
</span><span class="boring">    println!(&quot;Building FEM dynamic model...&quot;);
</span><span class="boring">    let mut fem = DiscreteStateSpace::from(FEM::from_pickle(
</span><span class="boring">        fem_data_path.join(&quot;modal_state_space_model_2ndOrder.73.pkl&quot;),
</span><span class="boring">    )?)
</span><span class="boring">    .dump_eigen_frequencies(fem_data_path.join(&quot;eigen_frequencies.pkl&quot;))
</span><span class="boring">    .sampling(sampling_rate)
</span><span class="boring">    .proportional_damping(2. / 100.)
</span><span class="boring">    .max_eigen_frequency(75.0)
</span><span class="boring">    .inputs_from(&amp;wind_loading)
</span><span class="boring">    .inputs_from(&amp;mnt_drives)
</span><span class="boring">    .outputs(vec![m1_rbm, m2_rbm])
</span><span class="boring">    .outputs(vec![
</span><span class="boring">        OSSAzEncoderAngle::io(),
</span><span class="boring">        OSSElEncoderAngle::io(),
</span><span class="boring">        OSSRotEncoderAngle::io(),
</span><span class="boring">    ])
</span><span class="boring">    .outputs(vec![OSSHardpointD::io()])
</span><span class="boring">    .build()?;
</span><span class="boring">    tic.print_toc();
</span><span class="boring">
</span><span class="boring">    // DATA LOGGING
</span><span class="boring">    /*let mut data = DataLogging::new()
</span><span class="boring">    .sampling_rate(sampling_rate)
</span><span class="boring">    //.key(m1_rbm.clone())
</span><span class="boring">    //.key(m2_rbm.clone())
</span><span class="boring">    .build();*/
</span><span class="boring">
</span><span class="boring">    // FEEDBACK LOOP
</span><span class="boring">    println!(&quot;Running model ...&quot;);
</span><span class="boring">    let tic = Timer::tic();
</span><span class="boring">    let mut mount_drives_forces = Some(vec![
</span><span class="boring">        OSSAzDriveTorque::io_with(vec![0f64; 12]),
</span><span class="boring">        OSSElDriveTorque::io_with(vec![0f64; 4]),
</span><span class="boring">        OSSRotDriveTorque::io_with(vec![0f64; 4]),
</span><span class="boring">    ]);
</span><span class="boring">    let mut m1_cg_fm: Option&lt;Vec&lt;IO&lt;Vec&lt;f64&gt;&gt;&gt;&gt; = None;
</span><span class="boring">    let mut k = 0;
</span><span class="boring">    while let Some(mut fem_forces) = wind_loading.outputs() {
</span><span class="boring">        // FEM
</span><span class="boring">        mount_drives_forces.as_mut().map(|x| {
</span><span class="boring">            fem_forces.append(x);
</span><span class="boring">        });
</span><span class="boring">        m1_cg_fm.as_ref().map(|x| {
</span><span class="boring">            fem_forces[OSSM1Lcl6F::io()] += &amp;x[0];
</span><span class="boring">            fem_forces[OSSCellLcl6F::io()] -= &amp;x[0];
</span><span class="boring">        });
</span><span class="boring">        let fem_outputs = fem
</span><span class="boring">            .in_step_out(Some(fem_forces))?
</span><span class="boring">            .ok_or(&quot;FEM output is empty&quot;)?;
</span><span class="boring">        // MOUNT CONTROLLER &amp; DRIVES
</span><span class="boring">        let mount_encoders = &amp;fem_outputs[2..5];
</span><span class="boring">        mount_drives_forces = mnt_ctrl
</span><span class="boring">            .in_step_out(Some(mount_encoders.to_vec()))?
</span><span class="boring">            .map(|mut x| {
</span><span class="boring">                x.extend_from_slice(mount_encoders);
</span><span class="boring">                mnt_drives.in_step_out(Some(x))
</span><span class="boring">            })
</span><span class="boring">            .unwrap()?;
</span><span class="boring">        // M1 HARDPOINT &amp; CG CONTROLLER
</span><span class="boring">        if k % 10 == 0 {
</span><span class="boring">            let mut m1_hp = vec![M1HPCmd::io_with(vec![0f64; 42])];
</span><span class="boring">            m1_hp.extend_from_slice(&amp;[fem_outputs[OSSHardpointD::io::&lt;()&gt;()].clone()]);
</span><span class="boring">            m1_cg_fm = m1_ctrl.in_step_out(m1_hardpoints.in_step_out(Some(m1_hp))?)?;
</span><span class="boring">        }
</span><span class="boring">        k += 1;
</span><span class="boring">    }
</span><span class="boring">    tic.print_toc();
</span><span class="boring">
</span><span class="boring">    // DATA LOGGING
</span><span class="boring">    //data.step()?;
</span><span class="boring">    //data.log(&amp;fem_outputs[0])?.log(&amp;fem_outputs[1])?;
</span><span class="boring">    /*
</span><span class="boring">    // OUTPUTS SAVING
</span><span class="boring">    let mut f = File::create(fem_data_path.join(&quot;mount_control.data.pkl&quot;)).unwrap();
</span><span class="boring">    pkl::to_writer(
</span><span class="boring">        &amp;mut f,
</span><span class="boring">        &amp;[
</span><span class="boring">            data.time_series(m1_rbm),
</span><span class="boring">            data.time_series(m2_rbm),
</span><span class="boring">            //data.time_series(M1HPLC::new()),
</span><span class="boring">            //data.time_series(M1CGFM::new()),
</span><span class="boring">            //data.time_series(OSSAzEncoderAngle::new()),
</span><span class="boring">            //data.time_series(OSSElEncoderAngle::new()),
</span><span class="boring">            //data.time_series(OSSRotEncoderAngle::new()),
</span><span class="boring">            //data.time_series(MountCmd::new()),
</span><span class="boring">        ],
</span><span class="boring">        true,
</span><span class="boring">    )
</span><span class="boring">    .unwrap();
</span><span class="boring">     */
</span><span class="boring">    Ok(())
</span><span class="boring">}
</span></code></pre>
<ul>
<li>the 2 parts mount controller with the mount control that takes the mount encoder FEM outputs and transform them into mount drive commands which is combined with the encoder data and converted by the mount drive model into mount drive torques applied to the FEM:</li>
</ul>
<pre><code class="language-rust ignore"><span class="boring">use dosio::{io::jar::*, io::IO, Dos};
</span><span class="boring">use fem::{dos::DiscreteStateSpace, FEM};
</span><span class="boring">use m1_ctrl as m1;
</span><span class="boring">use mount_ctrl as mount;
</span><span class="boring">//use serde_pickle as pkl;
</span><span class="boring">use simple_logger::SimpleLogger;
</span><span class="boring">use windloading::WindLoads;
</span><span class="boring">//use std::error::Error;
</span><span class="boring">use std::path::Path;
</span><span class="boring">use std::time::Instant;
</span><span class="boring">//use std::{fs::File, io::Error};
</span><span class="boring">
</span><span class="boring">struct Timer {
</span><span class="boring">    time: Instant,
</span><span class="boring">}
</span><span class="boring">impl Timer {
</span><span class="boring">    pub fn tic() -&gt; Self {
</span><span class="boring">        Self {
</span><span class="boring">            time: Instant::now(),
</span><span class="boring">        }
</span><span class="boring">    }
</span><span class="boring">    pub fn toc(self) -&gt; f64 {
</span><span class="boring">        self.time.elapsed().as_secs_f64()
</span><span class="boring">    }
</span><span class="boring">    pub fn print_toc(self) {
</span><span class="boring">        println!(&quot;... in {:3}s&quot;, self.toc());
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">fn main() -&gt; Result&lt;(), Box&lt;dyn std::error::Error&gt;&gt; {
</span><span class="boring">    SimpleLogger::new().init().unwrap();
</span><span class="boring">    let fem_data_path = Path::new(&quot;data&quot;).join(&quot;20210225_1447_MT_mount_v202102_ASM_wind2&quot;);
</span><span class="boring">    // WIND LOADS
</span><span class="boring">    let tic = Timer::tic();
</span><span class="boring">    println!(&quot;Loading wind loads ...&quot;);
</span><span class="boring">    let mut wind_loading = WindLoads::from_pickle(
</span><span class="boring">        fem_data_path.join(&quot;b2019_0z_30az_os_7ms.wind_loads_1kHz_100-400s.pkl&quot;),
</span><span class="boring">    )?
</span><span class="boring">    .range(0.0, 20.0)
</span><span class="boring">    .truss()?
</span><span class="boring">    .m2_asm_topend()?
</span><span class="boring">    .m1_segments()?
</span><span class="boring">    .m1_cell()?
</span><span class="boring">    .m2_asm_reference_bodies()?
</span><span class="boring">    .build()?;
</span><span class="boring">    tic.print_toc();
</span><span class="boring">
</span><span class="boring">    // MOUNT CONTROL
</span>    let mut mnt_drives = mount::drives::Controller::new();
    let mut mnt_ctrl = mount::controller::Controller::new();
<span class="boring">
</span><span class="boring">    // M1
</span><span class="boring">    let mut m1_hardpoints = m1::hp_load_cells::Controller::new();
</span><span class="boring">    let mut m1_ctrl = m1::cg_controller::Controller::new();
</span><span class="boring">
</span><span class="boring">    // FEM
</span><span class="boring">    let sampling_rate = 1e3;
</span><span class="boring">    let m1_rbm = OSSM1Lcl::io();
</span><span class="boring">    let m2_rbm = MCM2RB6D::io();
</span><span class="boring">    let tic = Timer::tic();
</span><span class="boring">    println!(&quot;Building FEM dynamic model...&quot;);
</span><span class="boring">    let mut fem = DiscreteStateSpace::from(FEM::from_pickle(
</span><span class="boring">        fem_data_path.join(&quot;modal_state_space_model_2ndOrder.73.pkl&quot;),
</span><span class="boring">    )?)
</span><span class="boring">    .dump_eigen_frequencies(fem_data_path.join(&quot;eigen_frequencies.pkl&quot;))
</span><span class="boring">    .sampling(sampling_rate)
</span><span class="boring">    .proportional_damping(2. / 100.)
</span><span class="boring">    .max_eigen_frequency(75.0)
</span><span class="boring">    .inputs_from(&amp;wind_loading)
</span><span class="boring">    .inputs_from(&amp;mnt_drives)
</span><span class="boring">    .outputs(vec![m1_rbm, m2_rbm])
</span><span class="boring">    .outputs(vec![
</span><span class="boring">        OSSAzEncoderAngle::io(),
</span><span class="boring">        OSSElEncoderAngle::io(),
</span><span class="boring">        OSSRotEncoderAngle::io(),
</span><span class="boring">    ])
</span><span class="boring">    .outputs(vec![OSSHardpointD::io()])
</span><span class="boring">    .build()?;
</span><span class="boring">    tic.print_toc();
</span><span class="boring">
</span><span class="boring">    // DATA LOGGING
</span><span class="boring">    /*let mut data = DataLogging::new()
</span><span class="boring">    .sampling_rate(sampling_rate)
</span><span class="boring">    //.key(m1_rbm.clone())
</span><span class="boring">    //.key(m2_rbm.clone())
</span><span class="boring">    .build();*/
</span><span class="boring">
</span><span class="boring">    // FEEDBACK LOOP
</span><span class="boring">    println!(&quot;Running model ...&quot;);
</span><span class="boring">    let tic = Timer::tic();
</span><span class="boring">    let mut mount_drives_forces = Some(vec![
</span><span class="boring">        OSSAzDriveTorque::io_with(vec![0f64; 12]),
</span><span class="boring">        OSSElDriveTorque::io_with(vec![0f64; 4]),
</span><span class="boring">        OSSRotDriveTorque::io_with(vec![0f64; 4]),
</span><span class="boring">    ]);
</span><span class="boring">    let mut m1_cg_fm: Option&lt;Vec&lt;IO&lt;Vec&lt;f64&gt;&gt;&gt;&gt; = None;
</span><span class="boring">    let mut k = 0;
</span><span class="boring">    while let Some(mut fem_forces) = wind_loading.outputs() {
</span><span class="boring">        // FEM
</span><span class="boring">        mount_drives_forces.as_mut().map(|x| {
</span><span class="boring">            fem_forces.append(x);
</span><span class="boring">        });
</span><span class="boring">        m1_cg_fm.as_ref().map(|x| {
</span><span class="boring">            fem_forces[OSSM1Lcl6F::io()] += &amp;x[0];
</span><span class="boring">            fem_forces[OSSCellLcl6F::io()] -= &amp;x[0];
</span><span class="boring">        });
</span><span class="boring">        let fem_outputs = fem
</span><span class="boring">            .in_step_out(Some(fem_forces))?
</span><span class="boring">            .ok_or(&quot;FEM output is empty&quot;)?;
</span><span class="boring">        // MOUNT CONTROLLER &amp; DRIVES
</span><span class="boring">        let mount_encoders = &amp;fem_outputs[2..5];
</span><span class="boring">        mount_drives_forces = mnt_ctrl
</span><span class="boring">            .in_step_out(Some(mount_encoders.to_vec()))?
</span><span class="boring">            .map(|mut x| {
</span><span class="boring">                x.extend_from_slice(mount_encoders);
</span><span class="boring">                mnt_drives.in_step_out(Some(x))
</span><span class="boring">            })
</span><span class="boring">            .unwrap()?;
</span><span class="boring">        // M1 HARDPOINT &amp; CG CONTROLLER
</span><span class="boring">        if k % 10 == 0 {
</span><span class="boring">            let mut m1_hp = vec![M1HPCmd::io_with(vec![0f64; 42])];
</span><span class="boring">            m1_hp.extend_from_slice(&amp;[fem_outputs[OSSHardpointD::io::&lt;()&gt;()].clone()]);
</span><span class="boring">            m1_cg_fm = m1_ctrl.in_step_out(m1_hardpoints.in_step_out(Some(m1_hp))?)?;
</span><span class="boring">        }
</span><span class="boring">        k += 1;
</span><span class="boring">    }
</span><span class="boring">    tic.print_toc();
</span><span class="boring">
</span><span class="boring">    // DATA LOGGING
</span><span class="boring">    //data.step()?;
</span><span class="boring">    //data.log(&amp;fem_outputs[0])?.log(&amp;fem_outputs[1])?;
</span><span class="boring">    /*
</span><span class="boring">    // OUTPUTS SAVING
</span><span class="boring">    let mut f = File::create(fem_data_path.join(&quot;mount_control.data.pkl&quot;)).unwrap();
</span><span class="boring">    pkl::to_writer(
</span><span class="boring">        &amp;mut f,
</span><span class="boring">        &amp;[
</span><span class="boring">            data.time_series(m1_rbm),
</span><span class="boring">            data.time_series(m2_rbm),
</span><span class="boring">            //data.time_series(M1HPLC::new()),
</span><span class="boring">            //data.time_series(M1CGFM::new()),
</span><span class="boring">            //data.time_series(OSSAzEncoderAngle::new()),
</span><span class="boring">            //data.time_series(OSSElEncoderAngle::new()),
</span><span class="boring">            //data.time_series(OSSRotEncoderAngle::new()),
</span><span class="boring">            //data.time_series(MountCmd::new()),
</span><span class="boring">        ],
</span><span class="boring">        true,
</span><span class="boring">    )
</span><span class="boring">    .unwrap();
</span><span class="boring">     */
</span><span class="boring">    Ok(())
</span><span class="boring">}
</span></code></pre>
<ul>
<li>the 2 parts M1 controller with the M1 load cells model that combines the M1 hardpoint commands with the FEM hardpoint displacement output to produce the M1 load cell to hardpoint command for the M1 CG controller that computes M1 CG force and moments applied to both FEM inputs of the M1 segments and cells:</li>
</ul>
<pre><code class="language-rust ignore"><span class="boring">use dosio::{io::jar::*, io::IO, Dos};
</span><span class="boring">use fem::{dos::DiscreteStateSpace, FEM};
</span><span class="boring">use m1_ctrl as m1;
</span><span class="boring">use mount_ctrl as mount;
</span><span class="boring">//use serde_pickle as pkl;
</span><span class="boring">use simple_logger::SimpleLogger;
</span><span class="boring">use windloading::WindLoads;
</span><span class="boring">//use std::error::Error;
</span><span class="boring">use std::path::Path;
</span><span class="boring">use std::time::Instant;
</span><span class="boring">//use std::{fs::File, io::Error};
</span><span class="boring">
</span><span class="boring">struct Timer {
</span><span class="boring">    time: Instant,
</span><span class="boring">}
</span><span class="boring">impl Timer {
</span><span class="boring">    pub fn tic() -&gt; Self {
</span><span class="boring">        Self {
</span><span class="boring">            time: Instant::now(),
</span><span class="boring">        }
</span><span class="boring">    }
</span><span class="boring">    pub fn toc(self) -&gt; f64 {
</span><span class="boring">        self.time.elapsed().as_secs_f64()
</span><span class="boring">    }
</span><span class="boring">    pub fn print_toc(self) {
</span><span class="boring">        println!(&quot;... in {:3}s&quot;, self.toc());
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">fn main() -&gt; Result&lt;(), Box&lt;dyn std::error::Error&gt;&gt; {
</span><span class="boring">    SimpleLogger::new().init().unwrap();
</span><span class="boring">    let fem_data_path = Path::new(&quot;data&quot;).join(&quot;20210225_1447_MT_mount_v202102_ASM_wind2&quot;);
</span><span class="boring">    // WIND LOADS
</span><span class="boring">    let tic = Timer::tic();
</span><span class="boring">    println!(&quot;Loading wind loads ...&quot;);
</span><span class="boring">    let mut wind_loading = WindLoads::from_pickle(
</span><span class="boring">        fem_data_path.join(&quot;b2019_0z_30az_os_7ms.wind_loads_1kHz_100-400s.pkl&quot;),
</span><span class="boring">    )?
</span><span class="boring">    .range(0.0, 20.0)
</span><span class="boring">    .truss()?
</span><span class="boring">    .m2_asm_topend()?
</span><span class="boring">    .m1_segments()?
</span><span class="boring">    .m1_cell()?
</span><span class="boring">    .m2_asm_reference_bodies()?
</span><span class="boring">    .build()?;
</span><span class="boring">    tic.print_toc();
</span><span class="boring">
</span><span class="boring">    // MOUNT CONTROL
</span><span class="boring">    let mut mnt_drives = mount::drives::Controller::new();
</span><span class="boring">    let mut mnt_ctrl = mount::controller::Controller::new();
</span><span class="boring">
</span><span class="boring">    // M1
</span>    let mut m1_hardpoints = m1::hp_load_cells::Controller::new();
    let mut m1_ctrl = m1::cg_controller::Controller::new();
<span class="boring">
</span><span class="boring">    // FEM
</span><span class="boring">    let sampling_rate = 1e3;
</span><span class="boring">    let m1_rbm = OSSM1Lcl::io();
</span><span class="boring">    let m2_rbm = MCM2RB6D::io();
</span><span class="boring">    let tic = Timer::tic();
</span><span class="boring">    println!(&quot;Building FEM dynamic model...&quot;);
</span><span class="boring">    let mut fem = DiscreteStateSpace::from(FEM::from_pickle(
</span><span class="boring">        fem_data_path.join(&quot;modal_state_space_model_2ndOrder.73.pkl&quot;),
</span><span class="boring">    )?)
</span><span class="boring">    .dump_eigen_frequencies(fem_data_path.join(&quot;eigen_frequencies.pkl&quot;))
</span><span class="boring">    .sampling(sampling_rate)
</span><span class="boring">    .proportional_damping(2. / 100.)
</span><span class="boring">    .max_eigen_frequency(75.0)
</span><span class="boring">    .inputs_from(&amp;wind_loading)
</span><span class="boring">    .inputs_from(&amp;mnt_drives)
</span><span class="boring">    .outputs(vec![m1_rbm, m2_rbm])
</span><span class="boring">    .outputs(vec![
</span><span class="boring">        OSSAzEncoderAngle::io(),
</span><span class="boring">        OSSElEncoderAngle::io(),
</span><span class="boring">        OSSRotEncoderAngle::io(),
</span><span class="boring">    ])
</span><span class="boring">    .outputs(vec![OSSHardpointD::io()])
</span><span class="boring">    .build()?;
</span><span class="boring">    tic.print_toc();
</span><span class="boring">
</span><span class="boring">    // DATA LOGGING
</span><span class="boring">    /*let mut data = DataLogging::new()
</span><span class="boring">    .sampling_rate(sampling_rate)
</span><span class="boring">    //.key(m1_rbm.clone())
</span><span class="boring">    //.key(m2_rbm.clone())
</span><span class="boring">    .build();*/
</span><span class="boring">
</span><span class="boring">    // FEEDBACK LOOP
</span><span class="boring">    println!(&quot;Running model ...&quot;);
</span><span class="boring">    let tic = Timer::tic();
</span><span class="boring">    let mut mount_drives_forces = Some(vec![
</span><span class="boring">        OSSAzDriveTorque::io_with(vec![0f64; 12]),
</span><span class="boring">        OSSElDriveTorque::io_with(vec![0f64; 4]),
</span><span class="boring">        OSSRotDriveTorque::io_with(vec![0f64; 4]),
</span><span class="boring">    ]);
</span><span class="boring">    let mut m1_cg_fm: Option&lt;Vec&lt;IO&lt;Vec&lt;f64&gt;&gt;&gt;&gt; = None;
</span><span class="boring">    let mut k = 0;
</span><span class="boring">    while let Some(mut fem_forces) = wind_loading.outputs() {
</span><span class="boring">        // FEM
</span><span class="boring">        mount_drives_forces.as_mut().map(|x| {
</span><span class="boring">            fem_forces.append(x);
</span><span class="boring">        });
</span><span class="boring">        m1_cg_fm.as_ref().map(|x| {
</span><span class="boring">            fem_forces[OSSM1Lcl6F::io()] += &amp;x[0];
</span><span class="boring">            fem_forces[OSSCellLcl6F::io()] -= &amp;x[0];
</span><span class="boring">        });
</span><span class="boring">        let fem_outputs = fem
</span><span class="boring">            .in_step_out(Some(fem_forces))?
</span><span class="boring">            .ok_or(&quot;FEM output is empty&quot;)?;
</span><span class="boring">        // MOUNT CONTROLLER &amp; DRIVES
</span><span class="boring">        let mount_encoders = &amp;fem_outputs[2..5];
</span><span class="boring">        mount_drives_forces = mnt_ctrl
</span><span class="boring">            .in_step_out(Some(mount_encoders.to_vec()))?
</span><span class="boring">            .map(|mut x| {
</span><span class="boring">                x.extend_from_slice(mount_encoders);
</span><span class="boring">                mnt_drives.in_step_out(Some(x))
</span><span class="boring">            })
</span><span class="boring">            .unwrap()?;
</span><span class="boring">        // M1 HARDPOINT &amp; CG CONTROLLER
</span><span class="boring">        if k % 10 == 0 {
</span><span class="boring">            let mut m1_hp = vec![M1HPCmd::io_with(vec![0f64; 42])];
</span><span class="boring">            m1_hp.extend_from_slice(&amp;[fem_outputs[OSSHardpointD::io::&lt;()&gt;()].clone()]);
</span><span class="boring">            m1_cg_fm = m1_ctrl.in_step_out(m1_hardpoints.in_step_out(Some(m1_hp))?)?;
</span><span class="boring">        }
</span><span class="boring">        k += 1;
</span><span class="boring">    }
</span><span class="boring">    tic.print_toc();
</span><span class="boring">
</span><span class="boring">    // DATA LOGGING
</span><span class="boring">    //data.step()?;
</span><span class="boring">    //data.log(&amp;fem_outputs[0])?.log(&amp;fem_outputs[1])?;
</span><span class="boring">    /*
</span><span class="boring">    // OUTPUTS SAVING
</span><span class="boring">    let mut f = File::create(fem_data_path.join(&quot;mount_control.data.pkl&quot;)).unwrap();
</span><span class="boring">    pkl::to_writer(
</span><span class="boring">        &amp;mut f,
</span><span class="boring">        &amp;[
</span><span class="boring">            data.time_series(m1_rbm),
</span><span class="boring">            data.time_series(m2_rbm),
</span><span class="boring">            //data.time_series(M1HPLC::new()),
</span><span class="boring">            //data.time_series(M1CGFM::new()),
</span><span class="boring">            //data.time_series(OSSAzEncoderAngle::new()),
</span><span class="boring">            //data.time_series(OSSElEncoderAngle::new()),
</span><span class="boring">            //data.time_series(OSSRotEncoderAngle::new()),
</span><span class="boring">            //data.time_series(MountCmd::new()),
</span><span class="boring">        ],
</span><span class="boring">        true,
</span><span class="boring">    )
</span><span class="boring">    .unwrap();
</span><span class="boring">     */
</span><span class="boring">    Ok(())
</span><span class="boring">}
</span></code></pre>
<p>Finally, the dynamic simulation is implemented such as wind loads are applied to the FEM of the telescope with the feedback loop controller between the mount 3 rotational axes drives and encoders and between M1 segments hardpoints and center of gravity:</p>
<pre><code class="language-rust ignore"><span class="boring">use dosio::{io::jar::*, io::IO, Dos};
</span><span class="boring">use fem::{dos::DiscreteStateSpace, FEM};
</span><span class="boring">use m1_ctrl as m1;
</span><span class="boring">use mount_ctrl as mount;
</span><span class="boring">//use serde_pickle as pkl;
</span><span class="boring">use simple_logger::SimpleLogger;
</span><span class="boring">use windloading::WindLoads;
</span><span class="boring">//use std::error::Error;
</span><span class="boring">use std::path::Path;
</span><span class="boring">use std::time::Instant;
</span><span class="boring">//use std::{fs::File, io::Error};
</span><span class="boring">
</span><span class="boring">struct Timer {
</span><span class="boring">    time: Instant,
</span><span class="boring">}
</span><span class="boring">impl Timer {
</span><span class="boring">    pub fn tic() -&gt; Self {
</span><span class="boring">        Self {
</span><span class="boring">            time: Instant::now(),
</span><span class="boring">        }
</span><span class="boring">    }
</span><span class="boring">    pub fn toc(self) -&gt; f64 {
</span><span class="boring">        self.time.elapsed().as_secs_f64()
</span><span class="boring">    }
</span><span class="boring">    pub fn print_toc(self) {
</span><span class="boring">        println!(&quot;... in {:3}s&quot;, self.toc());
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">fn main() -&gt; Result&lt;(), Box&lt;dyn std::error::Error&gt;&gt; {
</span><span class="boring">    SimpleLogger::new().init().unwrap();
</span><span class="boring">    let fem_data_path = Path::new(&quot;data&quot;).join(&quot;20210225_1447_MT_mount_v202102_ASM_wind2&quot;);
</span><span class="boring">    // WIND LOADS
</span><span class="boring">    let tic = Timer::tic();
</span><span class="boring">    println!(&quot;Loading wind loads ...&quot;);
</span><span class="boring">    let mut wind_loading = WindLoads::from_pickle(
</span><span class="boring">        fem_data_path.join(&quot;b2019_0z_30az_os_7ms.wind_loads_1kHz_100-400s.pkl&quot;),
</span><span class="boring">    )?
</span><span class="boring">    .range(0.0, 20.0)
</span><span class="boring">    .truss()?
</span><span class="boring">    .m2_asm_topend()?
</span><span class="boring">    .m1_segments()?
</span><span class="boring">    .m1_cell()?
</span><span class="boring">    .m2_asm_reference_bodies()?
</span><span class="boring">    .build()?;
</span><span class="boring">    tic.print_toc();
</span><span class="boring">
</span><span class="boring">    // MOUNT CONTROL
</span><span class="boring">    let mut mnt_drives = mount::drives::Controller::new();
</span><span class="boring">    let mut mnt_ctrl = mount::controller::Controller::new();
</span><span class="boring">
</span><span class="boring">    // M1
</span><span class="boring">    let mut m1_hardpoints = m1::hp_load_cells::Controller::new();
</span><span class="boring">    let mut m1_ctrl = m1::cg_controller::Controller::new();
</span><span class="boring">
</span><span class="boring">    // FEM
</span><span class="boring">    let sampling_rate = 1e3;
</span><span class="boring">    let m1_rbm = OSSM1Lcl::io();
</span><span class="boring">    let m2_rbm = MCM2RB6D::io();
</span><span class="boring">    let tic = Timer::tic();
</span><span class="boring">    println!(&quot;Building FEM dynamic model...&quot;);
</span><span class="boring">    let mut fem = DiscreteStateSpace::from(FEM::from_pickle(
</span><span class="boring">        fem_data_path.join(&quot;modal_state_space_model_2ndOrder.73.pkl&quot;),
</span><span class="boring">    )?)
</span><span class="boring">    .dump_eigen_frequencies(fem_data_path.join(&quot;eigen_frequencies.pkl&quot;))
</span><span class="boring">    .sampling(sampling_rate)
</span><span class="boring">    .proportional_damping(2. / 100.)
</span><span class="boring">    .max_eigen_frequency(75.0)
</span><span class="boring">    .inputs_from(&amp;wind_loading)
</span><span class="boring">    .inputs_from(&amp;mnt_drives)
</span><span class="boring">    .outputs(vec![m1_rbm, m2_rbm])
</span><span class="boring">    .outputs(vec![
</span><span class="boring">        OSSAzEncoderAngle::io(),
</span><span class="boring">        OSSElEncoderAngle::io(),
</span><span class="boring">        OSSRotEncoderAngle::io(),
</span><span class="boring">    ])
</span><span class="boring">    .outputs(vec![OSSHardpointD::io()])
</span><span class="boring">    .build()?;
</span><span class="boring">    tic.print_toc();
</span><span class="boring">
</span><span class="boring">    // DATA LOGGING
</span><span class="boring">    /*let mut data = DataLogging::new()
</span><span class="boring">    .sampling_rate(sampling_rate)
</span><span class="boring">    //.key(m1_rbm.clone())
</span><span class="boring">    //.key(m2_rbm.clone())
</span><span class="boring">    .build();*/
</span><span class="boring">
</span><span class="boring">    // FEEDBACK LOOP
</span><span class="boring">    println!(&quot;Running model ...&quot;);
</span><span class="boring">    let tic = Timer::tic();
</span>    let mut mount_drives_forces = Some(vec![
        OSSAzDriveTorque::io_with(vec![0f64; 12]),
        OSSElDriveTorque::io_with(vec![0f64; 4]),
        OSSRotDriveTorque::io_with(vec![0f64; 4]),
    ]);
    let mut m1_cg_fm: Option&lt;Vec&lt;IO&lt;Vec&lt;f64&gt;&gt;&gt;&gt; = None;
    let mut k = 0;
    while let Some(mut fem_forces) = wind_loading.outputs() {
        // FEM
        mount_drives_forces.as_mut().map(|x| {
            fem_forces.append(x);
        });
        m1_cg_fm.as_ref().map(|x| {
            fem_forces[OSSM1Lcl6F::io()] += &amp;x[0];
            fem_forces[OSSCellLcl6F::io()] -= &amp;x[0];
        });
        let fem_outputs = fem
            .in_step_out(Some(fem_forces))?
            .ok_or(&quot;FEM output is empty&quot;)?;
        // MOUNT CONTROLLER &amp; DRIVES
        let mount_encoders = &amp;fem_outputs[2..5];
        mount_drives_forces = mnt_ctrl
            .in_step_out(Some(mount_encoders.to_vec()))?
            .map(|mut x| {
                x.extend_from_slice(mount_encoders);
                mnt_drives.in_step_out(Some(x))
            })
            .unwrap()?;
        // M1 HARDPOINT &amp; CG CONTROLLER
        if k % 10 == 0 {
            let mut m1_hp = vec![M1HPCmd::io_with(vec![0f64; 42])];
            m1_hp.extend_from_slice(&amp;[fem_outputs[OSSHardpointD::io::&lt;()&gt;()].clone()]);
            m1_cg_fm = m1_ctrl.in_step_out(m1_hardpoints.in_step_out(Some(m1_hp))?)?;
        }
        k += 1;
    }
<span class="boring">    tic.print_toc();
</span><span class="boring">
</span><span class="boring">    // DATA LOGGING
</span><span class="boring">    //data.step()?;
</span><span class="boring">    //data.log(&amp;fem_outputs[0])?.log(&amp;fem_outputs[1])?;
</span><span class="boring">    /*
</span><span class="boring">    // OUTPUTS SAVING
</span><span class="boring">    let mut f = File::create(fem_data_path.join(&quot;mount_control.data.pkl&quot;)).unwrap();
</span><span class="boring">    pkl::to_writer(
</span><span class="boring">        &amp;mut f,
</span><span class="boring">        &amp;[
</span><span class="boring">            data.time_series(m1_rbm),
</span><span class="boring">            data.time_series(m2_rbm),
</span><span class="boring">            //data.time_series(M1HPLC::new()),
</span><span class="boring">            //data.time_series(M1CGFM::new()),
</span><span class="boring">            //data.time_series(OSSAzEncoderAngle::new()),
</span><span class="boring">            //data.time_series(OSSElEncoderAngle::new()),
</span><span class="boring">            //data.time_series(OSSRotEncoderAngle::new()),
</span><span class="boring">            //data.time_series(MountCmd::new()),
</span><span class="boring">        ],
</span><span class="boring">        true,
</span><span class="boring">    )
</span><span class="boring">    .unwrap();
</span><span class="boring">     */
</span><span class="boring">    Ok(())
</span><span class="boring">}
</span></code></pre>
<h1 id="appendix"><a class="header" href="#appendix">Appendix</a></h1>
<h1 id="io-variants"><a class="header" href="#io-variants">IO variants</a></h1>
<pre><code class="language-rust ignore">    // Uniform Wind Pressure
    OSSTopEnd6F,  // Top-End
    MCM2Lcl6F,    // M2 segments
    OSSTruss6F,   //Truss
    OSSM1Lcl6F,   // M1 segments
    OSSCellLcl6F, // M1 segment cells
    OSSGIR6F,     // GIR
    OSSCRING6F,   // C-rings
    // Axial wind forces on M1 mirror segments
    M1DistributedWindf,
    // Axial displacement of M1 segment surface nodes
    M1Segment1AxialD,
    M1Segment2AxialD,
    M1Segment3AxialD,
    M1Segment4AxialD,
    M1Segment5AxialD,
    M1Segment6AxialD,
    M1Segment7AxialD,
    // M1 hardpoints
    OSSHarpointDeltaF, // forces
    OSSHardpointD,     // displacements
    // M1 Actuators forces applied to back-side of M1 segments
    M1ActuatorsSegment1,
    M1ActuatorsSegment2,
    M1ActuatorsSegment3,
    M1ActuatorsSegment4,
    M1actuatorsSegment5,
    M1actuatorsSegment6,
    M1ActuatorsSegment7,
    // M1 fans
    OSSM1FansLcl6F,
    OSSM1FansLcl6D,
    // Payloads
    OSSPayloads6F,
    OSSPayloads6D,
    // Mount Drives
    OSSAzDriveF,  // azimuth drive
    OSSElDriveF,  // elevation drive
    OSSGIRDriveF, // GIR drive
    OSSAzDriveD,
    OSSElDriveD,
    OSSGIRDriveD,
    // Mount Drives
    OSSAzDriveTorque,
    OSSElDriveTorque,
    OSSRotDriveTorque,
    OSSAzEncoderAngle,
    OSSElEncoderAngle,
    OSSRotEncoderAngle,
    // Azimuth, elevation, rotation drive torques
    SlewTorques,
    // Line of sight
    OSSM1LOS,  // M1
    MCM2LOS6D, // M2
    // Base of Pier
    OSSBASE6F,
    // Inertial Measurement Units
    OSSIMUs6d,
    // M2 Positioners
    MCM2SmHexF,
    // ASM Proof Mass Actuators
    MCM2PMA1F,
    // ASM
    MCM2CP6F,  // Cold plates
    MCM2RB6F,  // Reference bodies
    MCM2CP6D,  // Cold plates
    MCM2RB6D,  // Reference bodies
    MCM2Lcl6D, // Face sheets
    MCASMCOG6F,
    MCASMCOG6D,
    //
    MCM2TE6F,
    MCM2TEIF6F,
    OSSTrussTEIF6f,
    MCM2GravCS0,
    MCM2PZTS1F,
    MCM2PZTS2F,
    MCM2PZTS3F,
    MCM2PZTS4F,
    MCM2PZTS5F,
    MCM2PZTS6F,
    MCM2PZTS7F,
    MCM2SmallS16F,
    MCM2SmallS26F,
    MCM2SmallS36F,
    MCM2SmallS46F,
    MCM2SmallS56F,
    MCM2SmallS66F,
    MCM2SmallS76F,
    OSSGravCS0,
    OSSTrussIF6D,
    OSSGIR6D,
    OSSCRING6D,
    OSSBASE6D,
    OSSM1Lcl,
    OSSTruss6d,
    OSSCellLcl,
    MCM2SmallS16D,
    MCM2PZTS1D,
    MCM2SmallS26D,
    MCM2PZTS2D,
    MCM2SmallS36D,
    MCM2PZTS3D,
    MCM2SmallS46D,
    MCM2PZTS4D,
    MCM2SmallS56D,
    MCM2PZTS5D,
    MCM2SmallS66D,
    MCM2PZTS6D,
    MCM2SmallS76D,
    MCM2PZTS7D,
    M1SurfacesD,
    M1EdgeSensors,
    MCM2CP1D,
    MCM2SmHexD,
    M2edgesensors,
    MCM2TEIF6D,
    MCM2TE6D,
    M2ReferenceBody1AxialD,
    M2ReferenceBody2AxialD,
    M2ReferenceBody3AxialD,
    M2ReferenceBody4AxialD,
    M2ReferenceBody5AxialD,
    M2ReferenceBody6AxialD,
    M2ReferenceBody7AxialD,
    MountCmd,
    // M1 control
    M1HPCmd,
    M1HPLC,
    M1CGFM,
    SensorData,
    SrcWfeRms,
    Pssn
</code></pre>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                        

                        

                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
                

                
            </nav>

        </div>

        

        

        

        
        <script type="text/javascript">
            window.playground_copyable = true;
        </script>
        

        

        
        <script src="elasticlunr.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="mark.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="searcher.js" type="text/javascript" charset="utf-8"></script>
        

        <script src="clipboard.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="highlight.js" type="text/javascript" charset="utf-8"></script>
        <script src="book.js" type="text/javascript" charset="utf-8"></script>

        <!-- Custom JS scripts -->
        

        
        
        <script type="text/javascript">
        window.addEventListener('load', function() {
            window.setTimeout(window.print, 100);
        });
        </script>
        
        

    </body>
</html>
